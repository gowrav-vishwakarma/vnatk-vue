{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"vnatk (vue-node agile tool kit) VNATK is a combination of frontend and backend framework to develop APP seemlessly, based on Vuetify & express-sequelize. While this documentation is dedicated to VNATK-VUE, The frontend part, you have to check its counter express-sequelize part also to get it work. Being a developer, I have seen developers repeating same tasks again and again and I really wanted to focus on what business needs. So, here I am with this Framework. vnatk-vue (VV) vnatk-vue is an extention of Vuetify and provides a set of Components to do the heavy lifting of your APP development. In this initial relase we have mostly focused on CRUD component as this single component boosted our Admin development process. But more components/plugins are under development to get things done really quick. While this framework provides you some components, you are still free to ignore this and keep continue with venilla Vuetify anytime. Dependencies The framework has the following dependencies Vue ^2.6.11 Vuetify ^2.2.11 axios ^0.21.0 lodash ^4.17.19 vue-papa-parse ^2.0.0 vuetify-form-base ^0.3.2 vnatk-express-sequelize (VES) vnatk-express-sequelize is the backend of this framework. This can be installed with any new or existing express-sequelize project and start fuling your things. This was inspired from GraphQL and in many sense can be condidered as its replacement for sequelize projects. Thugh, I have just tested it with MySQL but since its just sequelize in back everything should work out of the box. Even if vnatk-express-sequelize (VES) installed you can simply ignore this and keep conitnue with your existing API system. To know more about VES please visit official vnatk-express-sequelize page","title":"Overview"},{"location":"#vnatk-vue-node-agile-tool-kit","text":"VNATK is a combination of frontend and backend framework to develop APP seemlessly, based on Vuetify & express-sequelize. While this documentation is dedicated to VNATK-VUE, The frontend part, you have to check its counter express-sequelize part also to get it work. Being a developer, I have seen developers repeating same tasks again and again and I really wanted to focus on what business needs. So, here I am with this Framework.","title":"vnatk (vue-node agile tool kit)"},{"location":"#vnatk-vue-vv","text":"vnatk-vue is an extention of Vuetify and provides a set of Components to do the heavy lifting of your APP development. In this initial relase we have mostly focused on CRUD component as this single component boosted our Admin development process. But more components/plugins are under development to get things done really quick. While this framework provides you some components, you are still free to ignore this and keep continue with venilla Vuetify anytime.","title":"vnatk-vue (VV)"},{"location":"#dependencies","text":"The framework has the following dependencies Vue ^2.6.11 Vuetify ^2.2.11 axios ^0.21.0 lodash ^4.17.19 vue-papa-parse ^2.0.0 vuetify-form-base ^0.3.2","title":"Dependencies"},{"location":"#vnatk-express-sequelize-ves","text":"vnatk-express-sequelize is the backend of this framework. This can be installed with any new or existing express-sequelize project and start fuling your things. This was inspired from GraphQL and in many sense can be condidered as its replacement for sequelize projects. Thugh, I have just tested it with MySQL but since its just sequelize in back everything should work out of the box. Even if vnatk-express-sequelize (VES) installed you can simply ignore this and keep conitnue with your existing API system. To know more about VES please visit official vnatk-express-sequelize page","title":"vnatk-express-sequelize (VES)"},{"location":"quickstart/","text":"QuickStart Pre-requisite Setup vnatk-express-sequelize While there is separate documentation of this project, we will cover basics here to get your minimum setup done. Just add the vnatk-express-sequelize in your existing express-sequelize project #install our dependencies now $yourProjectRoot/server> npm install --save bcrypt body-parser cookie-parser express-handlebars jsonwebtoken morgan cors dotenv lodash mysql2 sequelize vnatk-express-sequelize it is must have sequelize setup done through #install sequelize cli for easy sequlize setup $yourProjectRoot/server> npm install --save-dev sequelize-cli $yourProjectRoot/server> sequelize init Setup routes Please add the following code in your app.js file. (DON'T COPY PASTE WHOLE CODE, ITS NOT FULL FILE CODE) app.js // somewhere on the top after // var express = require('express'); <= after this line var cors = require('cors'); const bodyParser = require('body-parser'); const vnatk = require('vnatk-express-sequelize'); ... ... // You can already have body-parser added, no need to add again app.use(bodyParser.json()); app.use(bodyParser.urlencoded({extended: true })); // add cors is a good way and mostly you might need this also app.use(cors()); // Use this after the variable declaration var VnatkRouter = require('./routes/vnatk.js'); app.use('/vnatk', VnatkRouter); // '/vnatk' is called basepath here Now create a new file to export Vnatk Routes routes/vnatk.js var express = require('express'); var router = express.Router(); const vnatk = require('vnatk-express-sequelize'); // Optional to use some auth middleware on this route //router.use(require('./middleware/adminTokenChecker')); const Models = require('../../models'); module.exports = vnatk({ Models: Models, router: router }); That's it, create your sequelize models and start using VES as alternative to GraphQL. There are some additional features you can use in Sequelize model if you are just not using it as API but also using this vnatk-vue. For those please ffollow coming up session. Vnatk-Vue Installation Assuming you have setup your VES (vnatk-express-sequelize) already on server side, please follow the steps below. Steps define setting up a project from scratch, feel free to skip initial steps if you want VV in your existing project. # just be sure you are in root of your project $yourProjectRoot> ls server #install vue-cli globally if not installed $yourProjectRoot> npm install -g @vue/cli $yourProjectRoot> vue create client #follow wizard, I preferred default for beginners $yourProjectRoot> ls client server $yourProjectRoot> cd client $yourProjectRoot/client> vue add vuetify # I prefer defaults for now #to make better use of views etc just add router $yourProjectRoot/client> vue add router $yourProjectRoot/client> npm install --save material-design-icons-iconfont axios lodash vuetify-form-base vue-papa-parse vnatk-vue Setup project for vnatk APP/Vuetify setup We are all set to use our system with defined model as in Back First we need to update plugins/vuetify.js file as per given code import Vue from 'vue'; import 'material-design-icons-iconfont/dist/material-design-icons.css' import 'vuetify/dist/vuetify.min.css' import Vuetify from \"vuetify\"; Vue.use(Vuetify, { iconfont: 'md', }); export default new Vuetify({ }); Also the default setup does not usage v-app from vuetify but just a div in src/App.vue . Lets edit that file also like following <template> <!-- this below v-app was div in starting --> <v-app id=\"app\"> <div id=\"nav\"> <router-link to=\"/\">Home</router-link> | <router-link to=\"/about\">About</router-link> </div> <router-view /> </v-app> </template> axios-services setup To connect our service/server let's create a folder services in your project src folder. Considering server/service we created in express setup above, is for customers. Create a file customer.js in services folder and place the following code there import axios from \"axios\"; const api = axios.create({ baseURL: process.env.VUE_APP_BASE_URL_CUSTOMER || \"http://localhost:3000\" }); export default api; Your first CRUD Our system is ready to rock, now we will just create models and methods in Sequlize at server side and views/page in Vue Frontend, The rest logic is well done by itself. for now open views/Home.vue file (You will only get this file if you have done vue add router , otherwise, please find suitable file for you) and place the following content to see the magic <template> <vnatk-crud :options=\"crudoptions\"> </vnatk-crud> </template> <script> import { VnatkCrud } from \"vnatk-vue\"; import customer from \"../services/customer\"; export default { name: \"SampleCRUD\", components: { VnatkCrud, }, data() { return { crudoptions: { service: customer, model: \"User\", title: \"Users\", }, }; }, }; </script> And your crud will be there with all avilable other actions also like the image below Notice city_id and state_id is automatically de-referenced to have their respective names from associations and all defined actions are available in drop down menu of each row. For more about additional features for seuelize models for vnatk-vue, please refer Sequelize Model Features By default system assumes name as title field that is shown instead of ID, but do not worry if you don't follow these notations, everything is customizable. This is how edit form and functionality is created.","title":"QuickStart"},{"location":"quickstart/#quickstart","text":"","title":"QuickStart"},{"location":"quickstart/#pre-requisite","text":"","title":"Pre-requisite"},{"location":"quickstart/#setup-vnatk-express-sequelize","text":"While there is separate documentation of this project, we will cover basics here to get your minimum setup done. Just add the vnatk-express-sequelize in your existing express-sequelize project #install our dependencies now $yourProjectRoot/server> npm install --save bcrypt body-parser cookie-parser express-handlebars jsonwebtoken morgan cors dotenv lodash mysql2 sequelize vnatk-express-sequelize it is must have sequelize setup done through #install sequelize cli for easy sequlize setup $yourProjectRoot/server> npm install --save-dev sequelize-cli $yourProjectRoot/server> sequelize init","title":"Setup vnatk-express-sequelize"},{"location":"quickstart/#setup-routes","text":"Please add the following code in your app.js file. (DON'T COPY PASTE WHOLE CODE, ITS NOT FULL FILE CODE) app.js // somewhere on the top after // var express = require('express'); <= after this line var cors = require('cors'); const bodyParser = require('body-parser'); const vnatk = require('vnatk-express-sequelize'); ... ... // You can already have body-parser added, no need to add again app.use(bodyParser.json()); app.use(bodyParser.urlencoded({extended: true })); // add cors is a good way and mostly you might need this also app.use(cors()); // Use this after the variable declaration var VnatkRouter = require('./routes/vnatk.js'); app.use('/vnatk', VnatkRouter); // '/vnatk' is called basepath here Now create a new file to export Vnatk Routes routes/vnatk.js var express = require('express'); var router = express.Router(); const vnatk = require('vnatk-express-sequelize'); // Optional to use some auth middleware on this route //router.use(require('./middleware/adminTokenChecker')); const Models = require('../../models'); module.exports = vnatk({ Models: Models, router: router }); That's it, create your sequelize models and start using VES as alternative to GraphQL. There are some additional features you can use in Sequelize model if you are just not using it as API but also using this vnatk-vue. For those please ffollow coming up session.","title":"Setup routes"},{"location":"quickstart/#vnatk-vue-installation","text":"Assuming you have setup your VES (vnatk-express-sequelize) already on server side, please follow the steps below. Steps define setting up a project from scratch, feel free to skip initial steps if you want VV in your existing project. # just be sure you are in root of your project $yourProjectRoot> ls server #install vue-cli globally if not installed $yourProjectRoot> npm install -g @vue/cli $yourProjectRoot> vue create client #follow wizard, I preferred default for beginners $yourProjectRoot> ls client server $yourProjectRoot> cd client $yourProjectRoot/client> vue add vuetify # I prefer defaults for now #to make better use of views etc just add router $yourProjectRoot/client> vue add router $yourProjectRoot/client> npm install --save material-design-icons-iconfont axios lodash vuetify-form-base vue-papa-parse vnatk-vue","title":"Vnatk-Vue Installation"},{"location":"quickstart/#setup-project-for-vnatk","text":"","title":"Setup project for vnatk"},{"location":"quickstart/#appvuetify-setup","text":"We are all set to use our system with defined model as in Back First we need to update plugins/vuetify.js file as per given code import Vue from 'vue'; import 'material-design-icons-iconfont/dist/material-design-icons.css' import 'vuetify/dist/vuetify.min.css' import Vuetify from \"vuetify\"; Vue.use(Vuetify, { iconfont: 'md', }); export default new Vuetify({ }); Also the default setup does not usage v-app from vuetify but just a div in src/App.vue . Lets edit that file also like following <template> <!-- this below v-app was div in starting --> <v-app id=\"app\"> <div id=\"nav\"> <router-link to=\"/\">Home</router-link> | <router-link to=\"/about\">About</router-link> </div> <router-view /> </v-app> </template>","title":"APP/Vuetify setup"},{"location":"quickstart/#axios-services-setup","text":"To connect our service/server let's create a folder services in your project src folder. Considering server/service we created in express setup above, is for customers. Create a file customer.js in services folder and place the following code there import axios from \"axios\"; const api = axios.create({ baseURL: process.env.VUE_APP_BASE_URL_CUSTOMER || \"http://localhost:3000\" }); export default api;","title":"axios-services setup"},{"location":"quickstart/#your-first-crud","text":"Our system is ready to rock, now we will just create models and methods in Sequlize at server side and views/page in Vue Frontend, The rest logic is well done by itself. for now open views/Home.vue file (You will only get this file if you have done vue add router , otherwise, please find suitable file for you) and place the following content to see the magic <template> <vnatk-crud :options=\"crudoptions\"> </vnatk-crud> </template> <script> import { VnatkCrud } from \"vnatk-vue\"; import customer from \"../services/customer\"; export default { name: \"SampleCRUD\", components: { VnatkCrud, }, data() { return { crudoptions: { service: customer, model: \"User\", title: \"Users\", }, }; }, }; </script> And your crud will be there with all avilable other actions also like the image below Notice city_id and state_id is automatically de-referenced to have their respective names from associations and all defined actions are available in drop down menu of each row. For more about additional features for seuelize models for vnatk-vue, please refer Sequelize Model Features By default system assumes name as title field that is shown instead of ID, but do not worry if you don't follow these notations, everything is customizable. This is how edit form and functionality is created.","title":"Your first CRUD"},{"location":"sequelize-model-features/","text":"Aditional Model Features If you are using VES (vnatk-express-sequelize) as your API powerhouse only, you can keep using Sequelize model system and it will work fine. But if you are using vantk-vue , you can add some more features on your sequelize models to automate a few things here on frontend. Model Specific titlefield Class Property [Optional] - default name VES will de-reference all realtions and try to find proper name to idetify related record. Default, it assumes your name field if defined in model is your title field. If, User belongsTo City , we have CityId in Users Table. if City has name field, VNATK will show City's name in data grid etc and even in autocomplete dropdown to type, while when saving its appropriate Id will be saved in User. But, if you have different field in Model that defines name for that record like identifier in Products table. you can create titlefield property to be value identifier , And rest VNATK will doing de-referencing with this field now. example module.exports = (sequelize, DataTypes) => { const Project = sequelize.define('Project', { // This field is supposed to be titlefield code: DataTypes.STRING, title: DataTypes.STRING, imageUrl: DataTypes.STRING, description: DataTypes.TEXT, adminId: DataTypes.INTEGER }, {}); // This is how you define your title field for model Project.titlefield = 'code'; Project.associate = function (models) { Project.belongsTo(models.User, { foreignKey: 'adminId', onDelete: 'CASCADE', as: 'ProjectAdmin' }) Project.belongsToMany(models.User, { foreignKey: 'adminId', onDelete: 'CASCADE', as: 'ProjectUsers', through: models.UserProjects }) }; return Project; }; vnAtkGetActions Class Method If defined this method returns various actions doable on records based on condition at vantk-crud frontend. module.exports = (sequelize, DataTypes) => { const Project = sequelize.define('Project', { // This field is supposed to be titlefield code: DataTypes.STRING, title: DataTypes.STRING, imageUrl: DataTypes.STRING, description: DataTypes.TEXT, adminId: DataTypes.INTEGER }, {}); // This is how you define your title field for model Project.titlefield = 'code'; Project.associate = function (models) { Project.belongsTo(models.User, { foreignKey: 'adminId', onDelete: 'CASCADE', as: 'ProjectAdmin' }) Project.belongsToMany(models.User, { foreignKey: 'adminId', onDelete: 'CASCADE', as: 'ProjectUsers', through: models.UserProjects }) }; Project.vnAtkGetActions = function (models) { return [{ name: \"deactivate\", // identifier of action type: 'single', // type Single, NoRecord, MultiRecord where: { // Condition to show action on frontend status: 'Active' }, execute: 'deActivate' // Model instance method to be called }, { name: \"activate\", type: 'single', where: { status: 'InActive' }, execute: 'Activate' }, { name: \"doSomething\", type: 'single', where: { status: 'InActive' }, formschema: { // pass formschema to display a form on action btn click and receive the data in method below \"name\": { \"type\": \"text\", \"label\": \"name\" }, \"password\": { \"type\": \"password\", \"clearable\": true, \"solo\": true, \"class\": \"mx-1 mt-1\" }, }, execute: 'doSomething' }, ]; }; Project.prototype.deActivate = async function () { this.status = 'InActive' return await this.save().then(self => { return self; }); }; Project.prototype.Activate = async function () { this.status = 'Active' return await this.save().then(self => { return self; }); }; Project.prototype.doSomething = function (formData) { console.log(formData); }; return Project; }; Action type can be one of three Single - Performable on one record, record will be loaded before executing, on frontend, these action will be displayed at row level. like activate/deactivate etc. NoRecord - Performable on NO record, Will be executed on non-loaded models, like vnatk_add etc MultiRecord - Under development, when used, Crud grid will have selection options, and all selected recrods will be available in propert 'vnatk_selected_records' of function argument. To study more about formschema please read more at Vuetify-Form-Base Field Specific Field specific features/properties can be added on field to effect frontend display caption String if specified will show better caption for field like . . . isDumped: { type: DataType.Boolean, caption: 'Dumped Project' } . . . ext String Vuetify-Form-Base specific attribute, please read more at Vuetify-Form-base for more. ui JSON VES try to guess best ui information from model, but you can pass the ui property in field itself and VES will just return this without trying to guess best ui header. . . . isDumped: { type: DataType.Boolean, ui: { type: 'Checkbox', text: 'Dumped Project' } } . . .","title":"Sequelize Model Features"},{"location":"sequelize-model-features/#aditional-model-features","text":"If you are using VES (vnatk-express-sequelize) as your API powerhouse only, you can keep using Sequelize model system and it will work fine. But if you are using vantk-vue , you can add some more features on your sequelize models to automate a few things here on frontend.","title":"Aditional Model Features"},{"location":"sequelize-model-features/#model-specific","text":"","title":"Model Specific"},{"location":"sequelize-model-features/#titlefield","text":"Class Property [Optional] - default name VES will de-reference all realtions and try to find proper name to idetify related record. Default, it assumes your name field if defined in model is your title field. If, User belongsTo City , we have CityId in Users Table. if City has name field, VNATK will show City's name in data grid etc and even in autocomplete dropdown to type, while when saving its appropriate Id will be saved in User. But, if you have different field in Model that defines name for that record like identifier in Products table. you can create titlefield property to be value identifier , And rest VNATK will doing de-referencing with this field now. example module.exports = (sequelize, DataTypes) => { const Project = sequelize.define('Project', { // This field is supposed to be titlefield code: DataTypes.STRING, title: DataTypes.STRING, imageUrl: DataTypes.STRING, description: DataTypes.TEXT, adminId: DataTypes.INTEGER }, {}); // This is how you define your title field for model Project.titlefield = 'code'; Project.associate = function (models) { Project.belongsTo(models.User, { foreignKey: 'adminId', onDelete: 'CASCADE', as: 'ProjectAdmin' }) Project.belongsToMany(models.User, { foreignKey: 'adminId', onDelete: 'CASCADE', as: 'ProjectUsers', through: models.UserProjects }) }; return Project; };","title":"titlefield"},{"location":"sequelize-model-features/#vnatkgetactions","text":"Class Method If defined this method returns various actions doable on records based on condition at vantk-crud frontend. module.exports = (sequelize, DataTypes) => { const Project = sequelize.define('Project', { // This field is supposed to be titlefield code: DataTypes.STRING, title: DataTypes.STRING, imageUrl: DataTypes.STRING, description: DataTypes.TEXT, adminId: DataTypes.INTEGER }, {}); // This is how you define your title field for model Project.titlefield = 'code'; Project.associate = function (models) { Project.belongsTo(models.User, { foreignKey: 'adminId', onDelete: 'CASCADE', as: 'ProjectAdmin' }) Project.belongsToMany(models.User, { foreignKey: 'adminId', onDelete: 'CASCADE', as: 'ProjectUsers', through: models.UserProjects }) }; Project.vnAtkGetActions = function (models) { return [{ name: \"deactivate\", // identifier of action type: 'single', // type Single, NoRecord, MultiRecord where: { // Condition to show action on frontend status: 'Active' }, execute: 'deActivate' // Model instance method to be called }, { name: \"activate\", type: 'single', where: { status: 'InActive' }, execute: 'Activate' }, { name: \"doSomething\", type: 'single', where: { status: 'InActive' }, formschema: { // pass formschema to display a form on action btn click and receive the data in method below \"name\": { \"type\": \"text\", \"label\": \"name\" }, \"password\": { \"type\": \"password\", \"clearable\": true, \"solo\": true, \"class\": \"mx-1 mt-1\" }, }, execute: 'doSomething' }, ]; }; Project.prototype.deActivate = async function () { this.status = 'InActive' return await this.save().then(self => { return self; }); }; Project.prototype.Activate = async function () { this.status = 'Active' return await this.save().then(self => { return self; }); }; Project.prototype.doSomething = function (formData) { console.log(formData); }; return Project; }; Action type can be one of three Single - Performable on one record, record will be loaded before executing, on frontend, these action will be displayed at row level. like activate/deactivate etc. NoRecord - Performable on NO record, Will be executed on non-loaded models, like vnatk_add etc MultiRecord - Under development, when used, Crud grid will have selection options, and all selected recrods will be available in propert 'vnatk_selected_records' of function argument. To study more about formschema please read more at Vuetify-Form-Base","title":"vnAtkGetActions"},{"location":"sequelize-model-features/#field-specific","text":"Field specific features/properties can be added on field to effect frontend display","title":"Field Specific"},{"location":"sequelize-model-features/#caption","text":"String if specified will show better caption for field like . . . isDumped: { type: DataType.Boolean, caption: 'Dumped Project' } . . .","title":"caption"},{"location":"sequelize-model-features/#ext","text":"String Vuetify-Form-Base specific attribute, please read more at Vuetify-Form-base for more.","title":"ext"},{"location":"sequelize-model-features/#ui","text":"JSON VES try to guess best ui information from model, but you can pass the ui property in field itself and VES will just return this without trying to guess best ui header. . . . isDumped: { type: DataType.Boolean, ui: { type: 'Checkbox', text: 'Dumped Project' } } . . .","title":"ui"},{"location":"using-vnatk-with-vuetify/","text":"This page shows more power of VES ( vnatk-express-sequelize ) and how you can leverage that as API less system for your queries from frontend. Considering you have installed VES on your server side, you can simply ask for any data without creating APIs for each and every trivial things. Lets just have an exmaple to understand, how you can use VES with vuetify, even not using vnatk-vue . This component code shows how you can use VES BASE_PATH/crud api to read anything. <template> <v-toolbar dense> <v-combobox v-model=\"selected_customer\" :items=\"customers_list\" :search-input.sync=\"customer_search_input\" item-text=\"title\" item-value=\"id\" hide-details clearable no-data-text=\"No Customer Found. Please try again!\" label=\"Search Customer Name\" class=\"pa-4 mb-4\" ></v-combobox> </v-toolbar> </template> <script> import customer from \"../services/customer\"; export default { name: \"CustomerSearch\", data() { return { customer_search_input: \"\", customers_list: [], selected_customer: null, }; }, watch: { //customer search customer_search_input: function (newValue) { if (!newValue) return; var postOptions = { model: \"User\", read: { modeloptions: { attributes: [\"mobile\", \"firstName\", \"lastName\", \"id\"], where: { $or: { mobile: { $like: \"%\" + newValue + \"%\", }, firstName: { $like: \"%\" + newValue + \"%\", }, lastName: { $like: \"%\" + newValue + \"%\", }, }, }, limit: 10, }, }, }; customer.post(\"/admin/vnatk/crud\", postOptions).then((response) => { this.customers_list = response.data.data.map((i) => { i.title = i.firstName + \" \" + i.lastName + \" \" + i.mobile; return i; }); }); }, }; </script> Interstingly, here we just created what we want from VES and recived data. also play attention how we just created new property title on fly and used that as item-text for v-combobox . Once installed VES, you can use it as alternative to GraphQL for sequlize. To know more about VES please visit Official Page of Vnatk-Express-Sequelize","title":"Using VES with Vuetify"},{"location":"components/","text":"Vantk-vue components vnatk-vue is planned to easy almost all sort of developments but due to our internal need we are focusing on CRUD component only. More components are under development and will be released when complete. vnatk-crud <vnatk-crud :options=\"crudoptions\" @before-action-execute='function1', @after-action-execute='function2' > More list Coming soon ...","title":"List"},{"location":"components/#vantk-vue-components","text":"vnatk-vue is planned to easy almost all sort of developments but due to our internal need we are focusing on CRUD component only. More components are under development and will be released when complete.","title":"Vantk-vue components"},{"location":"components/#vnatk-crud","text":"<vnatk-crud :options=\"crudoptions\" @before-action-execute='function1', @after-action-execute='function2' > More list Coming soon ...","title":"vnatk-crud"},{"location":"components/CRUD/","text":"vnatk-crud <vnatk-crud :options=\"crudoptions\" @before-action-execute='function1', (action,item, selectedItems) args @after-action-execute='function2' (metaData,response.data) @on-data-fetch='function3' // data as arguments @before-dialog-open='function4' // (action,CurrentItemCopy, OriginalRowItem) args @after-dialog-open='function4' // (action,CurrentItemCopy, OriginalRowItem) args @before-import='function5' // (data) args @after-import='function6' // (data) args > <!-- also use slots as per vuetify datatable --> <!-- You will have following slots for adding your own menu buttons --> <template v-slot:MenuTopLeftBefore> <template v-slot:MenuTopLeftAfter> <template v-slot:MenuTopRightBefore> <template v-slot:MenuTopRightAfter> Sample crud option passing A sample crud option can be as follows <template> <vnatk-crud :options=\"crudoptions\"> </vnatk-crud> </template> <script> import { VnatkCrud } from \"vnatk-vue\"; import customer from \"../services/customer\"; export default { name: \"SampleCRUD\", components: { VnatkCrud, }, data() { return { crudoptions: { service: customer, model: \"User\", title: \"Users\", }, }; }, }; </script> Crud Options service axios_instance [Mandatory] Since VNATK is designed around microservices, you can have multiple services to deal with, provide any axios instance as service to do requests by vnatk-crud component. basepath String [Optional] defaults to \"/vnatk\" for your service But since you may have defined some other route for vnatk like admin/vnatk or api/vnatk . provide this string to route your vnatk request to proper url for provided service. model String [Mandatory] Sequelize Model name to work on with this crud, This model will be considered with its default scope. You can change the scope to deal with further options coming. title String [Optional] Provides title of your crud quicksearch Array/Function/Boolean [Optional] quicksearch adds a input box at top-right of crud and allws you to search in your data. quicksearch: true will search in your local crud data. (Client side only.) quicksearch: ['field1', 'field2'] This format will work if your pagination is set to server mode, vnatk-crud will perform a like query on the fields provided with user entered value and results will filter in crud. quicksearch: (usertext)=>{ // do some change in read.modeloptions as per your need } when given as function you can modify crud options based on usertext and vue reactivity will reload crud with new options. create Boolean/JSON [Optional] - default true When provided just boolean, you just inform if you want to have a create facility or not. true : If true, system will add a add button and will get all Sequelize Model fields with their relations to have a create form populated. on save it does add record too. false : If false, system will skip add facility for your crud. json : When provided a json object you can customize create feature, let's see json object options in detail create.uititle String [Optional] Title of Dialog opened create.modeloptions JSON [Optional] - default {} Model options to be passed to Sequelize model.create( HERE ) crudoptions:{ service: customer, model: 'User' create: { modeloptions: { attributes: [\"name\", \"email\", \"status\", \"city_id\", \"password\"], }, } } create.defaultvalues JSON/Function [Optional] - default {} Lets say you are showing Users that are employee only so you are using crudoptions.read.modeloptions.modelscope:'employee' But when you create a new User, you don't want to add userType in create form but this should go as default value. You can do this by following example Default value as String crudoptions:{ service: customer, model: 'User' create: { modeloptions: { attributes: [\"name\", \"email\", \"status\", \"city_id\", \"password\"], }, defaultvalues:{ userType:'employee' } } } Default value as function any default value can be provided by function also to do some logic on your data going to submit and set your default value based on that logic crudoptions:{ service: customer, model: 'User' create: { modeloptions: { attributes: [\"name\", \"email\", \"status\", \"city_id\", \"password\"], }, defaultvalues:{ userType: function(item){ // your logic here like // if email contains company-domain.com return 'employee' // else return 'user' // A return value is must to have } } } } read JSON [Optional] - default {} Provides information to vnatk-express-seuelize and vnatk-vue to handle your data. You can customize read options by JSON properties. read.modeloptions JSON [Optional] - default {} Options for your sequelize model, With a few minor modifications, you can almost use any Sequelize model's option here what you can use in model.findAll (if not using serversidepagination) or you can use in model.findAndCountAll . Three things are surely different then those model options are how we define operators , scope and sequelize.fn in our read.modeloptions For operator - Use operator alias for operators like in example below For scope - Since you define model with string the main model scope is defined by crudoptions.read.modelscope property and for include options in your modeloptions you can define separate scope property to be populated at server side. For fn - you can pass json object with fn, col and as property to rebuild sequelize.fn at server side Lets have an exmaple to do it now. Please read all the comments to get more about read.modeloptions read: { modeloptions: { subQuery:false, attributes: [ \"name\", \"email\", \"status\", \"state_id\", \"city_id\", \"mobile\", ], // include: [\"City\", \"State\"], // to get all attributes with including without any further customizing (Same as sequelize docs) include: [ { model: \"City\", attributes: [\"name\", \"status\"], // get only these attributes (Same as sequelize docs) required: false, // To have OUTER LEFT JOIN instead INNER JOIN (Same as sequelize docs) scope: false, // or text (since we define Models as string, scope can be passed as property here) (VNATK-SPECIFIC ) }, { model: \"State\", attributes: [\"name\", \"status\", \"gst_code\"], required: false, }, { // No relations and wrong models but just to write somewhere till we create proper documentation model: \"Project\", as: \"ProjectsOwned\", attributes: [{ fn: \"count\", col: \"*\", as: \"ProjAdminCount\" }], }, { model: \"Project\", as: \"Projects\", attributes: [ { fn: \"count\", col: \"*\", as: \"ProjectPartOf\", through: { attributes: [] }, }, ], }, ], group: [\"User.id\"], }, } read.modelscope Boolean/String [Optional] - undefined Remember this option effects main model defined in crudoptions while individual scopes in include are just with scope property undefined or not defined : If not defined, the VES will apply defaultscope like what would sequelize do. false : set this value to false, model at the server end will be unscoped. String : if set as any string, system will load the scope by defined name, if not found at server model, system will throw an error. read.autoderef Boolean [Optional] - default true VNATK finds relations at server side with sequelize models and solves relations to get de-referenced data here. Like if user belongsTo City, autderef will also return you the city name by including this attribute by default and also shows in crud. You have total control over this also how to display what, that will come in later options. But if you want to skip it doing all de-ref for you, just set it false. remember setting this false will also result in all Autocomplete etc not working automatically. read.serversidepagination Boolean [Optional] - default false The default behaviour is to get all data and do the pagination at client side, but if the data is big or you want serverside pagination, just set this option to true. rest limit, page number etc will be taken care of. For better understanding please see datatableoptions exmaple. read.datatableoptions JSON [Optional] - default from v-data-table This is synced option with v-data-table options, so you can use the same options here what you use for v-data-table like serversidepagination: true, datatableoptions: { page: number, itemsPerPage: number, sortBy: string[], sortDesc: boolean[], groupBy: string[], groupDesc: boolean[], multiSort: boolean, mustSort: boolean }, update Boolean/JSON [Optional] - default true if set to false, Editing option will be unavailable for the crud. if provided with JSON object, you can customize Editing feature. To edit any field, you must have that in your read.modeloptions.attributes or the system will throw error update.uititle String [Optional] Title of Editing Window update.modeloptions Mostly used to define what fields you want to edit, rest options will be just passed to your sequelize model. update: { uititle: \"Edit User - {name}\", modeloptions: { attributes: [ \"name\", \"email\", \"status\", \"city_id\", // If autoderef is true, these relations will be converted to autocomplete automatically \"state_id\", \"mobile\", ], }, }, delete Boolean [Optional] - default true If set to false, system will remove deleting facility from crud. action Boolean [Optional] - default true If set to true, VES (vue-express-sequelize) will send all doable actions and the related actions will be visible in CRUD. To skip having actions fetched set this value to false . To read about how you can define actions from sequelize model, Please see Sequelize Model Features ui JSON [Optional] - default undefiend defines options for crud, like default action placement place and headers for v-data-table ui.defaultActionPlacement String[DropDown/buttonGroup] [Optional] - default DropDown Where by default you want your actions to be placed in crud, DropwDown will add them in menu at the end of Row, buttonGroup will add actions in buttons in action column. ui.headers Array of Objects [Optional] - default undefined Vantk-crud retrives all headers from sequelize itself, You can even override headers by other options, but many times overriding will be more work to do if you need to show only 2 columns and to hide rest 15 columns, just replace headers coming from server by defining here ui: { defaultActionPlacement: \"DropDown\", // Skip headeres received from server and use these as base to mix with override later headers: [ { text: \"Identifier\", value: \"identifier\", }, { text: \"Attribute Group\", value: \"AttributeGroup.name\", }, { // Don't forget to add actions column manually in case of heaers defined in ui and // actions: true (default) text: \"Actions\", value: \"vnatk_actions\", }, ], }, ui.datatableoptions Object [Optional] - default {datatable options} ui.datatableoptions.paginator Object [Optional] - default { totalPageVisible: 5, itemsPerPageOptions: [2, 5, 10, 50 - 1]} { read:{}, ... ui:{ datatableoptions: { paginator: { totalPageVisible: 5, itemsPerPageOptions: [2, 5, 10, 50 - 1], }, }, } } set paginator: false for default pagination override JSON [Optional] - default undefined you can always override actions and headers to customize your own need. You just have to override only actions/headers that you want to modify. override.actions Array of Objects define what actions you want to override, each object in this array must have a name property to identify which action to override and rest properties shows what to override. vnatk has a few predefined reserved action names vnatk_add vnatk_edit vnatk_delete To create forms at runtime fromsequelize model details VNATK is using Vuetify-Form-Base a great plugin to convert your json as beautiful vuetify forms. It will always be a great help to study that also. Lets have an complete example and then go each option one by one. Please read comments for better unerstaing in the examples override: { actions: [ { name: \"vnatk_edit\", // edit action is given specially this name placeIn: \"buttonGroup\", // or \"DropDown\" // use this to merge formschema options formschemaoverrides: { mobile: { label: \"Mobile Number\", }, city_id: { // titlefield - only used if field is reference/association type // default titlefield is considered as name or as defined in sequelize model titlefield: \"City.name\", // autocomplete text field from recived data label: \"Your City\", serviceoptions: { service: customer, // To have data from other service then default service defined for crud basepath: \"/vnatk\", model: \"City\", modelattributes: [\"id\", \"name\"], searchfield: \"name\", // autocomplete search q for like in the field limit: 10, }, }, email: { clearable: true, }, // state_id: { // titlefield: \"State.name\", // no state_id related info is overrided, still working good, in this case: using same service to get details if id,name is required with default limit // }, }, }, // Override individual field ... { name: \"vnatk_add\", // add action is given specially this name // use this to merge formschema options formschemaoverrides: { city_id: { label: \"Your City ... \", }, }, }, // OR override completely with new form and handle it via import way { name: \"vnatk_add\", formschema: { identifier: { type: \"text\", label: \"Your Identifier\", }, name_in_eng: { type: \"text\", label: \"Name in Eng\", }, vendor: { lable: \"VendorList\", type: \"autocomplete\", searchInput: \"\", serviceoptions: { service: catalog, basepath: \"/admin/vnatk\", model: \"Vendor\", modelattributes: [\"id\", \"first_name\", \"company\"], searchfield: [\"company\", \"first_name\"], // autocomplete search q for like in the field limit: 10, titlefield: function (o) { return o.company + \" of Mr. \" + o.first_name; }, }, }, }, handleviaimport: true, rowformatter: function (formData) { formData.createdById = 1; return formData; }, }, { name: \"activate\", placeIn: \"buttonGroup\", // or \"DropDown\" icon: \"mdi-format-align-left\", caption: \"Activate User\", // formschema:{} // use this to override complete formschema // formschemaoverrides:{} // use this to merge formschema options }, { name: \"deactivate\", placeIn: \"buttonGroup\", caption: \"Deactivate\", // icon: \"mdi-format-align-left\", }, { name: \"clientFunction\", type: \"NoRecord\", execute: this.clientFunctionCallBack, isClientAction: true, }, ], } override.actions[].name String [Mandatory] Used to identify which action to override override.actions[].placeIn String[buttonGroup/DropDown] [Optional] - default DropDown where you want to place the action, in dropdown menu at the end of row or in buttonGroup. override.actions[].formschemaoverrides JSON [Optional] VES, sends actions and their schema well defined from server, but many times you want to override its scham at client side based on need. you can override each field's schema by defining field_id as key and JSON schema to be overrided as value. Remember, only values that you override will be overrided and rest values will be taken as recieved from server. please see override.actions for complete example. override.headers JSON [Optional] VES sends all related headrs via initial server call, still you need to hide/add extra header through this options Lets have a full exmaple of override.headers option, please read the comments for better understanding VES also sends one header valued vnatk_actions to render all actions in it, you can override that too. override: { actions: [ ... ], headers: { /* field:{ option: value } */ city_id: { hide: true, // vnatk specific property to hide a column in v-data-table }, state_id: { hide: true, }, mobile: { text: \"User Mobile\", sortable: true, // value: \"mobile\", // moveto: 0, }, City: { // Override DeReferanced Fields (received from server due to autoderef) text: \"Primary City\", //Overrided header caption/text value: \"City.name\", // Value does not have effect as alrady overrided column by slot in template above // moveto: 2, }, \"State.gst_code\": { text: \"State GST Code\", value: \"State.gst_code\", sortable: true, moveto: 4, }, vnatk_actions: { moveto: \"last\", }, }, }, import JSON [Optional] - default undefined If defined as JSON, your crud will have an import button at top to import data. Data will previewed first and when proceeded, sent to VES for importing into defined model at root option. Also you can restructure data as seqlize relations and all deep data create with all relations will be done at server. Lets have an complete example and then understand each option. If using import don't forget to use vue-papa-parse to use either on your component or globally on Vue instance <script> import Vue from \"vue\"; import VuePapaParse from \"vue-papa-parse\"; Vue.use(VuePapaParse); . . . crudoptions:{ . . , import: { service: catalog, basepath: \"/admin/vnatk\", model: \"User\", execute: \"vnatk_import\", // or any other funtion you want to pass this data to in your model autoimport: true, // ignores execute options and just try to bulk create from given data by default vnatk action transaction: \"file\", // defaults to 'file' / or 'row'. In 'file' mode, data will rollback for all rows in case of error in any row, in 'row' mode, rows that are not imported are only rolled back and errored rows are reported back on import dialog. rowformatter: function (item) { // return false on any condition to skip this particular row. if(item.name=='') return false; item.$vnatk_data_handle = \"alwaysCreate\"; // 'alwaysCreate' [default], 'findOrCreate','findAndUpdateOrCreate', (For Associations, two more options) 'findToAssociate' [Produce error if not found],'associateIfFound' [Ignores if not found] item.$vnatk_find_options = {}; // if not provided, finding will be based on all fields and values defined above, used for where condition on model item.$vnatk_cache_records = true; // default to true, set false to find each time even if same condition is already found previously item.$vnatk_update_data = {}; // update only fields and their values defined here (if found), if this option is not provided, all fields defined above will be updated. item.City = { //Data to create or Update (if not defined vnatk_update_data) name: item.city_name, status: item.city_status, $vnatk_data_handle: \"alwaysCreate\", // 'alwaysCreate' [default], 'findOrCreate','findAndUpdateOrCreate',(For Associations, two more options) 'findToAssociate' [Produce error if not found],'associateIfFound' [Ignores if not found] $vnatk_find_options: { modeloptions: { where:{} // if required }, modescope: false, }, // if not provided, finding will be based on all fields and values defined above $vnatk_cache_records: true, // default to true, set false to find each time even if same condition is already found previously $vnatk_update_data: {}, // update only fields and their values defined here (if found), if this option is not provided, all fields defined above will be updated. }; item.FavPlaces = [ //hasMany relations: set as Array of Object, Each object defines one hasMany/many2many entry { //Data to create or Update (if not defined vnatk_update_data) name: item.fav_place_name_1, $vnatk_data_handle: \"alwaysCreate\", // 'alwaysCreate' [default],'findToAssociate' [Produce error if not found],'findOrCreate','findAndUpdateOrCreate','associateIfFound' [Ignores if not found] $vnatk_find_options: {}, $vnatk_cache_records: true, // default to true, set false to find each time even if same condition is already found previously $vnatk_update_data: {}, $set_fresh_relations: false, // default to false, if set true all data with this relation will be removed first }, { //Data to create or Update (if not defined vnatk_update_data) name: item.fav_place_name_2, $vnatk_data_handle: \"alwaysCreate\", // 'alwaysCreate' [default],'findToAssociate' [Produce error if not found],'findOrCreate','findAndUpdateOrCreate','associateIfFound' [Ignores if not found] $vnatk_find_options: {}, $vnatk_cache_records: true, // default to true, set false to find each time even if same condition is already found previously $vnatk_update_data: {}, }, { //Data to create or Update (if not defined vnatk_update_data) name: item.fav_place_name_3, $vnatk_data_handle: \"alwaysCreate\", // 'alwaysCreate' [default],'findToAssociate' [Produce error if not found],'findOrCreate','findAndUpdateOrCreate','associateIfFound' [Ignores if not found] $vnatk_find_options: {}, $vnatk_cache_records: true, // default to true, set false to find each time even if same condition is already found previously $vnatk_update_data: {}, }, ]; delete item.city_name; delete item.city_status; return i; }, success: this.reloadPage, }, } import.service axios_instance [Optional] - default to root service if not defined, vnatk will use root service import.basepath String [Optional] - defaults to root basepath defaults to crudoptions basepath import.model String [Optional] - defaults to root model Sequelize Model name to import into. import.execute String [Optional] Specify which model class method is to be called to handle the data at server side import.autoimport Boolean [Optional] - default false If set to true, import.execute value is ignored and VES will try to import all data by itself, remember, you can always set data in Sequelize data structure and VES will import all nested data with maintaining all relations. import.transaction String[file/row] [Optional] - default file How you want to handle import transaction, By default, on any error, no data will be imported and everything will be rollbacked, but if specified row , Importer will do every row in different transaction and on error in any row, only that row will be rolled back. import.rowformatter function [Optional] - default undefined if defined, importer will map all rows to this function and returned value of this function will be used for that row instead. This way, you can define arrange data from flat csv/excel data to Strcutured data. For example please see import options. rowformatter allowes you to add $vnatk_ properties in root item as well as all nested data, next section describes what are those $vnatk_ handlers for import. import.errorhandler function [Optional] - default undefined VV try to manage coming errors well, but in case you want to handle errors by your won, you can create this property Returned String will be shown at the top of import preview page. import: { autoimport: true, rowformatter: function (item) { // set default values in importer item.userType = \"employee\"; return item; }, errorhandler: function (err) { return err.response.data.Exception.errors .map((e) => e.message) .join(\"<br/>\"); }, }, $vantk_ handlers explained You can add the following $vnatk_ properties in importing row items (at root level as well as nested level) This will guide VES how you want to treat a particular relation or row. $vnatk_data_handle : This property has following options to be passed as string values alwaysCreate : with this option, importer will always insert data in table findOrCreate : with this option, importer will try to find record in table based on all fields values, if found no data will be inserted. For relations (Nested belongsTo, belongsTomany) founded Id will be used to make relations. if you have another criteria to search not by all fields, you can set $vnatk_find_options findAndUpdateOrCreate : with this option, importer will find (Either by all fields or as per $vnatk_find_options if defined) and if found, values for item will be updated. If not found the record will be instered. For relations, if not created, founded record primary key will be used to set relations as per data. findToAssociate : with this option, importer will find record by all fields or as per $vnatk_find_options if defined. If found record will be used to associate, like importing users and associating them with existing City. But if not found, this throws error. associateIfFound : with this option, importer will try to find record by all fields or as per $vnatk_find_options if defined. If found record will be used to associate, like importing users and associating them with existing Group. But if not found, importer will simply skip association. $vnatk_find_options : This property has following options to be passed as string values. If defined, this option guides importer to find a record. If not defined system will find by all items. like, if you want to find a City, if not found want to create it with status Active. What if the City is already in database but deactivated, you don't want to find by name and status. modelscope : false to unscope model before finding, or String to set scope for model. modeloptions : JSON , provides where condition for find. This only allows you to define where condition, attributes or include are not permitted here. import.success function|callback [Optional] - default undefined If defined, once importer is finished with importing, this function will be called by passing response data from VES API. Crud Events vnatk-crud extends v-data-table from Vuetify, Hence, all attributes and events on v-data-table should work here too. In addition to this vnatk-crud emits two events. before-action-execute This event emits just before any action is about to execute passing two parameters action object and item object. <vnatk-crud :options=\"crudoptions\" @before-action-execute='function1', > . . . <script> export default { . . . methods: { function1(action, item){ // DO YOUR STUFF HERE } } } </script> after-action-execute This event emits when responce is received and success callback is called. This event passes two parameters to handler function metaData object (payload that was sent for this event) and responseData (received response data) object. <vnatk-crud :options=\"crudoptions\" @after-action-execute='function2', > . . . <script> export default { . . . methods: { function2(metaData, responseData){ // DO YOUR STUFF HERE } } } </script>","title":"vnatk-crud component"},{"location":"components/CRUD/#vnatk-crud","text":"<vnatk-crud :options=\"crudoptions\" @before-action-execute='function1', (action,item, selectedItems) args @after-action-execute='function2' (metaData,response.data) @on-data-fetch='function3' // data as arguments @before-dialog-open='function4' // (action,CurrentItemCopy, OriginalRowItem) args @after-dialog-open='function4' // (action,CurrentItemCopy, OriginalRowItem) args @before-import='function5' // (data) args @after-import='function6' // (data) args > <!-- also use slots as per vuetify datatable --> <!-- You will have following slots for adding your own menu buttons --> <template v-slot:MenuTopLeftBefore> <template v-slot:MenuTopLeftAfter> <template v-slot:MenuTopRightBefore> <template v-slot:MenuTopRightAfter>","title":"vnatk-crud"},{"location":"components/CRUD/#sample-crud-option-passing","text":"A sample crud option can be as follows <template> <vnatk-crud :options=\"crudoptions\"> </vnatk-crud> </template> <script> import { VnatkCrud } from \"vnatk-vue\"; import customer from \"../services/customer\"; export default { name: \"SampleCRUD\", components: { VnatkCrud, }, data() { return { crudoptions: { service: customer, model: \"User\", title: \"Users\", }, }; }, }; </script>","title":"Sample crud option passing"},{"location":"components/CRUD/#crud-options","text":"","title":"Crud Options"},{"location":"components/CRUD/#service","text":"axios_instance [Mandatory] Since VNATK is designed around microservices, you can have multiple services to deal with, provide any axios instance as service to do requests by vnatk-crud component.","title":"service"},{"location":"components/CRUD/#basepath","text":"String [Optional] defaults to \"/vnatk\" for your service But since you may have defined some other route for vnatk like admin/vnatk or api/vnatk . provide this string to route your vnatk request to proper url for provided service.","title":"basepath"},{"location":"components/CRUD/#model","text":"String [Mandatory] Sequelize Model name to work on with this crud, This model will be considered with its default scope. You can change the scope to deal with further options coming.","title":"model"},{"location":"components/CRUD/#title","text":"String [Optional] Provides title of your crud","title":"title"},{"location":"components/CRUD/#quicksearch","text":"Array/Function/Boolean [Optional] quicksearch adds a input box at top-right of crud and allws you to search in your data. quicksearch: true will search in your local crud data. (Client side only.) quicksearch: ['field1', 'field2'] This format will work if your pagination is set to server mode, vnatk-crud will perform a like query on the fields provided with user entered value and results will filter in crud. quicksearch: (usertext)=>{ // do some change in read.modeloptions as per your need } when given as function you can modify crud options based on usertext and vue reactivity will reload crud with new options.","title":"quicksearch"},{"location":"components/CRUD/#create","text":"Boolean/JSON [Optional] - default true When provided just boolean, you just inform if you want to have a create facility or not. true : If true, system will add a add button and will get all Sequelize Model fields with their relations to have a create form populated. on save it does add record too. false : If false, system will skip add facility for your crud. json : When provided a json object you can customize create feature, let's see json object options in detail","title":"create"},{"location":"components/CRUD/#createuititle","text":"String [Optional] Title of Dialog opened","title":"create.uititle"},{"location":"components/CRUD/#createmodeloptions","text":"JSON [Optional] - default {} Model options to be passed to Sequelize model.create( HERE ) crudoptions:{ service: customer, model: 'User' create: { modeloptions: { attributes: [\"name\", \"email\", \"status\", \"city_id\", \"password\"], }, } }","title":"create.modeloptions"},{"location":"components/CRUD/#createdefaultvalues","text":"JSON/Function [Optional] - default {} Lets say you are showing Users that are employee only so you are using crudoptions.read.modeloptions.modelscope:'employee' But when you create a new User, you don't want to add userType in create form but this should go as default value. You can do this by following example Default value as String crudoptions:{ service: customer, model: 'User' create: { modeloptions: { attributes: [\"name\", \"email\", \"status\", \"city_id\", \"password\"], }, defaultvalues:{ userType:'employee' } } } Default value as function any default value can be provided by function also to do some logic on your data going to submit and set your default value based on that logic crudoptions:{ service: customer, model: 'User' create: { modeloptions: { attributes: [\"name\", \"email\", \"status\", \"city_id\", \"password\"], }, defaultvalues:{ userType: function(item){ // your logic here like // if email contains company-domain.com return 'employee' // else return 'user' // A return value is must to have } } } }","title":"create.defaultvalues"},{"location":"components/CRUD/#read","text":"JSON [Optional] - default {} Provides information to vnatk-express-seuelize and vnatk-vue to handle your data. You can customize read options by JSON properties.","title":"read"},{"location":"components/CRUD/#readmodeloptions","text":"JSON [Optional] - default {} Options for your sequelize model, With a few minor modifications, you can almost use any Sequelize model's option here what you can use in model.findAll (if not using serversidepagination) or you can use in model.findAndCountAll . Three things are surely different then those model options are how we define operators , scope and sequelize.fn in our read.modeloptions For operator - Use operator alias for operators like in example below For scope - Since you define model with string the main model scope is defined by crudoptions.read.modelscope property and for include options in your modeloptions you can define separate scope property to be populated at server side. For fn - you can pass json object with fn, col and as property to rebuild sequelize.fn at server side Lets have an exmaple to do it now. Please read all the comments to get more about read.modeloptions read: { modeloptions: { subQuery:false, attributes: [ \"name\", \"email\", \"status\", \"state_id\", \"city_id\", \"mobile\", ], // include: [\"City\", \"State\"], // to get all attributes with including without any further customizing (Same as sequelize docs) include: [ { model: \"City\", attributes: [\"name\", \"status\"], // get only these attributes (Same as sequelize docs) required: false, // To have OUTER LEFT JOIN instead INNER JOIN (Same as sequelize docs) scope: false, // or text (since we define Models as string, scope can be passed as property here) (VNATK-SPECIFIC ) }, { model: \"State\", attributes: [\"name\", \"status\", \"gst_code\"], required: false, }, { // No relations and wrong models but just to write somewhere till we create proper documentation model: \"Project\", as: \"ProjectsOwned\", attributes: [{ fn: \"count\", col: \"*\", as: \"ProjAdminCount\" }], }, { model: \"Project\", as: \"Projects\", attributes: [ { fn: \"count\", col: \"*\", as: \"ProjectPartOf\", through: { attributes: [] }, }, ], }, ], group: [\"User.id\"], }, }","title":"read.modeloptions"},{"location":"components/CRUD/#readmodelscope","text":"Boolean/String [Optional] - undefined Remember this option effects main model defined in crudoptions while individual scopes in include are just with scope property undefined or not defined : If not defined, the VES will apply defaultscope like what would sequelize do. false : set this value to false, model at the server end will be unscoped. String : if set as any string, system will load the scope by defined name, if not found at server model, system will throw an error.","title":"read.modelscope"},{"location":"components/CRUD/#readautoderef","text":"Boolean [Optional] - default true VNATK finds relations at server side with sequelize models and solves relations to get de-referenced data here. Like if user belongsTo City, autderef will also return you the city name by including this attribute by default and also shows in crud. You have total control over this also how to display what, that will come in later options. But if you want to skip it doing all de-ref for you, just set it false. remember setting this false will also result in all Autocomplete etc not working automatically.","title":"read.autoderef"},{"location":"components/CRUD/#readserversidepagination","text":"Boolean [Optional] - default false The default behaviour is to get all data and do the pagination at client side, but if the data is big or you want serverside pagination, just set this option to true. rest limit, page number etc will be taken care of. For better understanding please see datatableoptions exmaple.","title":"read.serversidepagination"},{"location":"components/CRUD/#readdatatableoptions","text":"JSON [Optional] - default from v-data-table This is synced option with v-data-table options, so you can use the same options here what you use for v-data-table like serversidepagination: true, datatableoptions: { page: number, itemsPerPage: number, sortBy: string[], sortDesc: boolean[], groupBy: string[], groupDesc: boolean[], multiSort: boolean, mustSort: boolean },","title":"read.datatableoptions"},{"location":"components/CRUD/#update","text":"Boolean/JSON [Optional] - default true if set to false, Editing option will be unavailable for the crud. if provided with JSON object, you can customize Editing feature. To edit any field, you must have that in your read.modeloptions.attributes or the system will throw error","title":"update"},{"location":"components/CRUD/#updateuititle","text":"String [Optional] Title of Editing Window","title":"update.uititle"},{"location":"components/CRUD/#updatemodeloptions","text":"Mostly used to define what fields you want to edit, rest options will be just passed to your sequelize model. update: { uititle: \"Edit User - {name}\", modeloptions: { attributes: [ \"name\", \"email\", \"status\", \"city_id\", // If autoderef is true, these relations will be converted to autocomplete automatically \"state_id\", \"mobile\", ], }, },","title":"update.modeloptions"},{"location":"components/CRUD/#delete","text":"Boolean [Optional] - default true If set to false, system will remove deleting facility from crud.","title":"delete"},{"location":"components/CRUD/#action","text":"Boolean [Optional] - default true If set to true, VES (vue-express-sequelize) will send all doable actions and the related actions will be visible in CRUD. To skip having actions fetched set this value to false . To read about how you can define actions from sequelize model, Please see Sequelize Model Features","title":"action"},{"location":"components/CRUD/#ui","text":"JSON [Optional] - default undefiend defines options for crud, like default action placement place and headers for v-data-table","title":"ui"},{"location":"components/CRUD/#uidefaultactionplacement","text":"String[DropDown/buttonGroup] [Optional] - default DropDown Where by default you want your actions to be placed in crud, DropwDown will add them in menu at the end of Row, buttonGroup will add actions in buttons in action column.","title":"ui.defaultActionPlacement"},{"location":"components/CRUD/#uiheaders","text":"Array of Objects [Optional] - default undefined Vantk-crud retrives all headers from sequelize itself, You can even override headers by other options, but many times overriding will be more work to do if you need to show only 2 columns and to hide rest 15 columns, just replace headers coming from server by defining here ui: { defaultActionPlacement: \"DropDown\", // Skip headeres received from server and use these as base to mix with override later headers: [ { text: \"Identifier\", value: \"identifier\", }, { text: \"Attribute Group\", value: \"AttributeGroup.name\", }, { // Don't forget to add actions column manually in case of heaers defined in ui and // actions: true (default) text: \"Actions\", value: \"vnatk_actions\", }, ], },","title":"ui.headers"},{"location":"components/CRUD/#uidatatableoptions","text":"Object [Optional] - default {datatable options}","title":"ui.datatableoptions"},{"location":"components/CRUD/#uidatatableoptionspaginator","text":"Object [Optional] - default { totalPageVisible: 5, itemsPerPageOptions: [2, 5, 10, 50 - 1]} { read:{}, ... ui:{ datatableoptions: { paginator: { totalPageVisible: 5, itemsPerPageOptions: [2, 5, 10, 50 - 1], }, }, } } set paginator: false for default pagination","title":"ui.datatableoptions.paginator"},{"location":"components/CRUD/#override","text":"JSON [Optional] - default undefined you can always override actions and headers to customize your own need. You just have to override only actions/headers that you want to modify.","title":"override"},{"location":"components/CRUD/#overrideactions","text":"Array of Objects define what actions you want to override, each object in this array must have a name property to identify which action to override and rest properties shows what to override. vnatk has a few predefined reserved action names vnatk_add vnatk_edit vnatk_delete To create forms at runtime fromsequelize model details VNATK is using Vuetify-Form-Base a great plugin to convert your json as beautiful vuetify forms. It will always be a great help to study that also. Lets have an complete example and then go each option one by one. Please read comments for better unerstaing in the examples override: { actions: [ { name: \"vnatk_edit\", // edit action is given specially this name placeIn: \"buttonGroup\", // or \"DropDown\" // use this to merge formschema options formschemaoverrides: { mobile: { label: \"Mobile Number\", }, city_id: { // titlefield - only used if field is reference/association type // default titlefield is considered as name or as defined in sequelize model titlefield: \"City.name\", // autocomplete text field from recived data label: \"Your City\", serviceoptions: { service: customer, // To have data from other service then default service defined for crud basepath: \"/vnatk\", model: \"City\", modelattributes: [\"id\", \"name\"], searchfield: \"name\", // autocomplete search q for like in the field limit: 10, }, }, email: { clearable: true, }, // state_id: { // titlefield: \"State.name\", // no state_id related info is overrided, still working good, in this case: using same service to get details if id,name is required with default limit // }, }, }, // Override individual field ... { name: \"vnatk_add\", // add action is given specially this name // use this to merge formschema options formschemaoverrides: { city_id: { label: \"Your City ... \", }, }, }, // OR override completely with new form and handle it via import way { name: \"vnatk_add\", formschema: { identifier: { type: \"text\", label: \"Your Identifier\", }, name_in_eng: { type: \"text\", label: \"Name in Eng\", }, vendor: { lable: \"VendorList\", type: \"autocomplete\", searchInput: \"\", serviceoptions: { service: catalog, basepath: \"/admin/vnatk\", model: \"Vendor\", modelattributes: [\"id\", \"first_name\", \"company\"], searchfield: [\"company\", \"first_name\"], // autocomplete search q for like in the field limit: 10, titlefield: function (o) { return o.company + \" of Mr. \" + o.first_name; }, }, }, }, handleviaimport: true, rowformatter: function (formData) { formData.createdById = 1; return formData; }, }, { name: \"activate\", placeIn: \"buttonGroup\", // or \"DropDown\" icon: \"mdi-format-align-left\", caption: \"Activate User\", // formschema:{} // use this to override complete formschema // formschemaoverrides:{} // use this to merge formschema options }, { name: \"deactivate\", placeIn: \"buttonGroup\", caption: \"Deactivate\", // icon: \"mdi-format-align-left\", }, { name: \"clientFunction\", type: \"NoRecord\", execute: this.clientFunctionCallBack, isClientAction: true, }, ], }","title":"override.actions"},{"location":"components/CRUD/#overrideactionsname","text":"String [Mandatory] Used to identify which action to override","title":"override.actions[].name"},{"location":"components/CRUD/#overrideactionsplacein","text":"String[buttonGroup/DropDown] [Optional] - default DropDown where you want to place the action, in dropdown menu at the end of row or in buttonGroup.","title":"override.actions[].placeIn"},{"location":"components/CRUD/#overrideactionsformschemaoverrides","text":"JSON [Optional] VES, sends actions and their schema well defined from server, but many times you want to override its scham at client side based on need. you can override each field's schema by defining field_id as key and JSON schema to be overrided as value. Remember, only values that you override will be overrided and rest values will be taken as recieved from server. please see override.actions for complete example.","title":"override.actions[].formschemaoverrides"},{"location":"components/CRUD/#overrideheaders","text":"JSON [Optional] VES sends all related headrs via initial server call, still you need to hide/add extra header through this options Lets have a full exmaple of override.headers option, please read the comments for better understanding VES also sends one header valued vnatk_actions to render all actions in it, you can override that too. override: { actions: [ ... ], headers: { /* field:{ option: value } */ city_id: { hide: true, // vnatk specific property to hide a column in v-data-table }, state_id: { hide: true, }, mobile: { text: \"User Mobile\", sortable: true, // value: \"mobile\", // moveto: 0, }, City: { // Override DeReferanced Fields (received from server due to autoderef) text: \"Primary City\", //Overrided header caption/text value: \"City.name\", // Value does not have effect as alrady overrided column by slot in template above // moveto: 2, }, \"State.gst_code\": { text: \"State GST Code\", value: \"State.gst_code\", sortable: true, moveto: 4, }, vnatk_actions: { moveto: \"last\", }, }, },","title":"override.headers"},{"location":"components/CRUD/#import","text":"JSON [Optional] - default undefined If defined as JSON, your crud will have an import button at top to import data. Data will previewed first and when proceeded, sent to VES for importing into defined model at root option. Also you can restructure data as seqlize relations and all deep data create with all relations will be done at server. Lets have an complete example and then understand each option. If using import don't forget to use vue-papa-parse to use either on your component or globally on Vue instance <script> import Vue from \"vue\"; import VuePapaParse from \"vue-papa-parse\"; Vue.use(VuePapaParse); . . . crudoptions:{ . . , import: { service: catalog, basepath: \"/admin/vnatk\", model: \"User\", execute: \"vnatk_import\", // or any other funtion you want to pass this data to in your model autoimport: true, // ignores execute options and just try to bulk create from given data by default vnatk action transaction: \"file\", // defaults to 'file' / or 'row'. In 'file' mode, data will rollback for all rows in case of error in any row, in 'row' mode, rows that are not imported are only rolled back and errored rows are reported back on import dialog. rowformatter: function (item) { // return false on any condition to skip this particular row. if(item.name=='') return false; item.$vnatk_data_handle = \"alwaysCreate\"; // 'alwaysCreate' [default], 'findOrCreate','findAndUpdateOrCreate', (For Associations, two more options) 'findToAssociate' [Produce error if not found],'associateIfFound' [Ignores if not found] item.$vnatk_find_options = {}; // if not provided, finding will be based on all fields and values defined above, used for where condition on model item.$vnatk_cache_records = true; // default to true, set false to find each time even if same condition is already found previously item.$vnatk_update_data = {}; // update only fields and their values defined here (if found), if this option is not provided, all fields defined above will be updated. item.City = { //Data to create or Update (if not defined vnatk_update_data) name: item.city_name, status: item.city_status, $vnatk_data_handle: \"alwaysCreate\", // 'alwaysCreate' [default], 'findOrCreate','findAndUpdateOrCreate',(For Associations, two more options) 'findToAssociate' [Produce error if not found],'associateIfFound' [Ignores if not found] $vnatk_find_options: { modeloptions: { where:{} // if required }, modescope: false, }, // if not provided, finding will be based on all fields and values defined above $vnatk_cache_records: true, // default to true, set false to find each time even if same condition is already found previously $vnatk_update_data: {}, // update only fields and their values defined here (if found), if this option is not provided, all fields defined above will be updated. }; item.FavPlaces = [ //hasMany relations: set as Array of Object, Each object defines one hasMany/many2many entry { //Data to create or Update (if not defined vnatk_update_data) name: item.fav_place_name_1, $vnatk_data_handle: \"alwaysCreate\", // 'alwaysCreate' [default],'findToAssociate' [Produce error if not found],'findOrCreate','findAndUpdateOrCreate','associateIfFound' [Ignores if not found] $vnatk_find_options: {}, $vnatk_cache_records: true, // default to true, set false to find each time even if same condition is already found previously $vnatk_update_data: {}, $set_fresh_relations: false, // default to false, if set true all data with this relation will be removed first }, { //Data to create or Update (if not defined vnatk_update_data) name: item.fav_place_name_2, $vnatk_data_handle: \"alwaysCreate\", // 'alwaysCreate' [default],'findToAssociate' [Produce error if not found],'findOrCreate','findAndUpdateOrCreate','associateIfFound' [Ignores if not found] $vnatk_find_options: {}, $vnatk_cache_records: true, // default to true, set false to find each time even if same condition is already found previously $vnatk_update_data: {}, }, { //Data to create or Update (if not defined vnatk_update_data) name: item.fav_place_name_3, $vnatk_data_handle: \"alwaysCreate\", // 'alwaysCreate' [default],'findToAssociate' [Produce error if not found],'findOrCreate','findAndUpdateOrCreate','associateIfFound' [Ignores if not found] $vnatk_find_options: {}, $vnatk_cache_records: true, // default to true, set false to find each time even if same condition is already found previously $vnatk_update_data: {}, }, ]; delete item.city_name; delete item.city_status; return i; }, success: this.reloadPage, }, }","title":"import"},{"location":"components/CRUD/#importservice","text":"axios_instance [Optional] - default to root service if not defined, vnatk will use root service","title":"import.service"},{"location":"components/CRUD/#importbasepath","text":"String [Optional] - defaults to root basepath defaults to crudoptions basepath","title":"import.basepath"},{"location":"components/CRUD/#importmodel","text":"String [Optional] - defaults to root model Sequelize Model name to import into.","title":"import.model"},{"location":"components/CRUD/#importexecute","text":"String [Optional] Specify which model class method is to be called to handle the data at server side","title":"import.execute"},{"location":"components/CRUD/#importautoimport","text":"Boolean [Optional] - default false If set to true, import.execute value is ignored and VES will try to import all data by itself, remember, you can always set data in Sequelize data structure and VES will import all nested data with maintaining all relations.","title":"import.autoimport"},{"location":"components/CRUD/#importtransaction","text":"String[file/row] [Optional] - default file How you want to handle import transaction, By default, on any error, no data will be imported and everything will be rollbacked, but if specified row , Importer will do every row in different transaction and on error in any row, only that row will be rolled back.","title":"import.transaction"},{"location":"components/CRUD/#importrowformatter","text":"function [Optional] - default undefined if defined, importer will map all rows to this function and returned value of this function will be used for that row instead. This way, you can define arrange data from flat csv/excel data to Strcutured data. For example please see import options. rowformatter allowes you to add $vnatk_ properties in root item as well as all nested data, next section describes what are those $vnatk_ handlers for import.","title":"import.rowformatter"},{"location":"components/CRUD/#importerrorhandler","text":"function [Optional] - default undefined VV try to manage coming errors well, but in case you want to handle errors by your won, you can create this property Returned String will be shown at the top of import preview page. import: { autoimport: true, rowformatter: function (item) { // set default values in importer item.userType = \"employee\"; return item; }, errorhandler: function (err) { return err.response.data.Exception.errors .map((e) => e.message) .join(\"<br/>\"); }, },","title":"import.errorhandler"},{"location":"components/CRUD/#vantk_-handlers-explained","text":"You can add the following $vnatk_ properties in importing row items (at root level as well as nested level) This will guide VES how you want to treat a particular relation or row. $vnatk_data_handle : This property has following options to be passed as string values alwaysCreate : with this option, importer will always insert data in table findOrCreate : with this option, importer will try to find record in table based on all fields values, if found no data will be inserted. For relations (Nested belongsTo, belongsTomany) founded Id will be used to make relations. if you have another criteria to search not by all fields, you can set $vnatk_find_options findAndUpdateOrCreate : with this option, importer will find (Either by all fields or as per $vnatk_find_options if defined) and if found, values for item will be updated. If not found the record will be instered. For relations, if not created, founded record primary key will be used to set relations as per data. findToAssociate : with this option, importer will find record by all fields or as per $vnatk_find_options if defined. If found record will be used to associate, like importing users and associating them with existing City. But if not found, this throws error. associateIfFound : with this option, importer will try to find record by all fields or as per $vnatk_find_options if defined. If found record will be used to associate, like importing users and associating them with existing Group. But if not found, importer will simply skip association. $vnatk_find_options : This property has following options to be passed as string values. If defined, this option guides importer to find a record. If not defined system will find by all items. like, if you want to find a City, if not found want to create it with status Active. What if the City is already in database but deactivated, you don't want to find by name and status. modelscope : false to unscope model before finding, or String to set scope for model. modeloptions : JSON , provides where condition for find. This only allows you to define where condition, attributes or include are not permitted here.","title":"$vantk_ handlers explained"},{"location":"components/CRUD/#importsuccess","text":"function|callback [Optional] - default undefined If defined, once importer is finished with importing, this function will be called by passing response data from VES API.","title":"import.success"},{"location":"components/CRUD/#crud-events","text":"vnatk-crud extends v-data-table from Vuetify, Hence, all attributes and events on v-data-table should work here too. In addition to this vnatk-crud emits two events.","title":"Crud Events"},{"location":"components/CRUD/#before-action-execute","text":"This event emits just before any action is about to execute passing two parameters action object and item object. <vnatk-crud :options=\"crudoptions\" @before-action-execute='function1', > . . . <script> export default { . . . methods: { function1(action, item){ // DO YOUR STUFF HERE } } } </script>","title":"before-action-execute"},{"location":"components/CRUD/#after-action-execute","text":"This event emits when responce is received and success callback is called. This event passes two parameters to handler function metaData object (payload that was sent for this event) and responseData (received response data) object. <vnatk-crud :options=\"crudoptions\" @after-action-execute='function2', > . . . <script> export default { . . . methods: { function2(metaData, responseData){ // DO YOUR STUFF HERE } } } </script>","title":"after-action-execute"}]}